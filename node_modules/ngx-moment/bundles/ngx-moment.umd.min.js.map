{"version":3,"sources":["../../../src/add.pipe.ts","../../../src/calendar.pipe.ts","../../../src/date-format.pipe.ts","../../../src/difference.pipe.ts","../../../src/moment-options.ts","../../../src/duration.pipe.ts","../../../src/from-unix.pipe.ts","../../../src/parse.pipe.ts","../../../src/from-utc.pipe.ts","../../../src/is-after.pipe.ts","../../../src/is-before.pipe.ts","../../../src/local.pipe.ts","../../../src/locale.pipe.ts","../../../src/parse-zone.pipe.ts","../../../src/subtract.pipe.ts","../../../src/time-ago.pipe.ts","../../../src/utc.pipe.ts","../../../src/moment.module.ts"],"names":["momentConstructor","moment","AddPipe","prototype","transform","value","amount","unit","Error","add","Pipe","args","name","CalendarPipe","cdRef","ngZone","_this","this","initTimer","refs","midnightSub","midnight","subscribe","run","markForCheck","_i","arguments","length","formats","referenceTime","i","len","moment.isMoment","calendar","ngOnDestroy","removeTimer","unsubscribe","EventEmitter","window","timeToUpdate_1","_getMillisecondsUntilUpdate","timer","runOutsideAngular","setTimeout","emit","Date","clearTimeout","now","startOf","valueOf","pure","ChangeDetectorRef","NgZone","DateFormatPipe","format","DifferencePipe","otherValue","precision","date","date2","diff","NGX_MOMENT_OPTIONS","InjectionToken","DurationPipe","momentOptions","allowedUnits","_applyOptions","moment.duration","humanize","relativeTimeThresholdOptions","Object","keys","filter","indexOf","forEach","moment.relativeTimeThreshold","Optional","type","Inject","FromUnixPipe","moment.unix","parseInt","ParsePipe","FromUtcPipe","moment.utc","IsAfterPipe","isAfter","IsBeforePipe","isBefore","LocalTimePipe","local","LocalePipe","locale","ParseZonePipe","moment.parseZone","SubtractPipe","subtract","TimeAgoPipe","m","from","lastOmitSuffix","omitSuffix","formatFn","hasChanged","lastTime","getTime","lastValue","lastLocale","getLocale","bind","createTimer","lastText","currentTimer","momentInstance","timeToUpdate","getSecondsUntilUpdate","howOld","Math","abs","moment.isDate","moment.locale","UtcPipe","utc","ANGULAR_MOMENT_PIPES","MomentModule","forRoot","options","ngModule","providers","provide","useValue","assign","NgModule","declarations","exports"],"mappings":"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","sourcesContent":["/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amAdd' })\nexport class AddPipe implements PipeTransform {\n  transform(\n    value: moment.MomentInput,\n    amount: moment.DurationInputArg1,\n    unit?: moment.DurationInputArg2,\n  ): any {\n    if (\n      typeof amount === 'undefined' ||\n      (typeof amount === 'number' && typeof unit === 'undefined')\n    ) {\n      throw new Error('AddPipe: missing required arguments');\n    }\n    return momentConstructor(value).add(amount, unit);\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport {\n  Pipe,\n  ChangeDetectorRef,\n  PipeTransform,\n  EventEmitter,\n  OnDestroy,\n  NgZone,\n} from '@angular/core';\nimport * as moment from 'moment';\nimport { Subscription } from 'rxjs';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amCalendar', pure: false })\nexport class CalendarPipe implements PipeTransform, OnDestroy {\n  /**\n   * Internal reference counter, so we can clean up when no instances are in use\n   */\n  private static refs = 0;\n\n  private static timer: number | null = null;\n  private static midnight: EventEmitter<Date> | null = null;\n\n  private midnightSub: Subscription;\n\n  constructor(private cdRef: ChangeDetectorRef, private ngZone: NgZone) {\n    // using a single static timer for all instances of this pipe for performance reasons\n    CalendarPipe.initTimer(ngZone);\n\n    CalendarPipe.refs++;\n\n    // values such as Today will need to be replaced with Yesterday after midnight,\n    // so make sure we subscribe to an EventEmitter that we set up to emit at midnight\n    this.midnightSub = CalendarPipe.midnight.subscribe(() => {\n      this.ngZone.run(() => this.cdRef.markForCheck());\n    });\n  }\n\n  transform(value: moment.MomentInput, ...args: any[]): any {\n    let formats: any = null;\n    let referenceTime: any = null;\n\n    for (let i = 0, len = args.length; i < len; i++) {\n      if (args[i] !== null) {\n        if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {\n          formats = args[i];\n        } else {\n          referenceTime = momentConstructor(args[i]);\n        }\n      }\n    }\n\n    return momentConstructor(value).calendar(referenceTime, formats);\n  }\n\n  ngOnDestroy(): void {\n    if (CalendarPipe.refs > 0) {\n      CalendarPipe.refs--;\n    }\n\n    if (CalendarPipe.refs === 0) {\n      CalendarPipe.removeTimer();\n    }\n\n    this.midnightSub.unsubscribe();\n  }\n\n  private static initTimer(ngZone: NgZone) {\n    // initialize the timer\n    if (!CalendarPipe.midnight) {\n      CalendarPipe.midnight = new EventEmitter<Date>();\n      if (typeof window !== 'undefined') {\n        const timeToUpdate = CalendarPipe._getMillisecondsUntilUpdate();\n        CalendarPipe.timer = ngZone.runOutsideAngular(() => {\n          return window.setTimeout(() => {\n            // emit the current date\n            CalendarPipe.midnight.emit(new Date());\n\n            // refresh the timer\n            CalendarPipe.removeTimer();\n            CalendarPipe.initTimer(ngZone);\n          }, timeToUpdate);\n        });\n      }\n    }\n  }\n\n  private static removeTimer() {\n    if (CalendarPipe.timer) {\n      window.clearTimeout(CalendarPipe.timer);\n      CalendarPipe.timer = null;\n      CalendarPipe.midnight = null;\n    }\n  }\n\n  private static _getMillisecondsUntilUpdate() {\n    const now = momentConstructor();\n    const tomorrow = momentConstructor().startOf('day').add(1, 'days');\n    const timeToMidnight = tomorrow.valueOf() - now.valueOf();\n    return timeToMidnight + 1000; // 1 second after midnight\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amDateFormat' })\nexport class DateFormatPipe implements PipeTransform {\n  transform(value: moment.MomentInput, ...args: any[]): string {\n    if (!value) {\n      return '';\n    }\n    return momentConstructor(value).format(args[0]);\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amDifference' })\nexport class DifferencePipe implements PipeTransform {\n  transform(\n    value: moment.MomentInput,\n    otherValue: moment.MomentInput,\n    unit?: moment.unitOfTime.Diff,\n    precision?: boolean,\n  ): number {\n    const date = momentConstructor(value);\n    const date2 = otherValue !== null ? momentConstructor(otherValue) : momentConstructor();\n\n    return date.diff(date2, unit, precision);\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const NGX_MOMENT_OPTIONS: InjectionToken<NgxMomentOptions> = new InjectionToken<\n  NgxMomentOptions\n>('NGX_MOMENT_OPTIONS');\n\nexport interface NgxMomentOptions {\n  /**\n   * relativeTimeThresholdOptions\n   * @description Provides the `relativeTimeThreshold` units allowing a pipe to set the `moment.relativeTimeThreshold` values.\n   * The `key` is a unit defined as one of `ss`, `s`, `m`, `h`, `d`, `M`.\n   * @see https://momentjs.com/docs/#/customization/relative-time-threshold/\n   * @example by default more than 45 seconds is considered a minute, more than 22 hours is considered a day and so on.\n   * So settings the unit 'm' to `59` will adjust the `relativeTimeThreshold` and consider more than 59 minutes\n   * to be an hour (default is `45 minutes`)\n   */\n  relativeTimeThresholdOptions: { [key: string]: number };\n}\n","import * as moment from 'moment';\n\nimport { Inject, Optional, Pipe, PipeTransform } from '@angular/core';\nimport { NGX_MOMENT_OPTIONS, NgxMomentOptions } from './moment-options';\n\n@Pipe({ name: 'amDuration' })\nexport class DurationPipe implements PipeTransform {\n  allowedUnits: Array<string> = ['ss', 's', 'm', 'h', 'd', 'M'];\n\n  constructor(@Optional() @Inject(NGX_MOMENT_OPTIONS) momentOptions?: NgxMomentOptions) {\n    this._applyOptions(momentOptions);\n  }\n\n  transform(value: moment.DurationInputArg1, ...args: string[]): string {\n    if (typeof args === 'undefined' || args.length !== 1) {\n      throw new Error('DurationPipe: missing required time unit argument');\n    }\n    return moment.duration(value, args[0] as moment.unitOfTime.DurationConstructor).humanize();\n  }\n\n  private _applyOptions(momentOptions: NgxMomentOptions): void {\n    if (!momentOptions) {\n      return;\n    }\n\n    if (!!momentOptions.relativeTimeThresholdOptions) {\n      const units: Array<string> = Object.keys(momentOptions.relativeTimeThresholdOptions);\n      const filteredUnits: Array<string> = units.filter(\n        (unit) => this.allowedUnits.indexOf(unit) !== -1,\n      );\n      filteredUnits.forEach((unit) => {\n        moment.relativeTimeThreshold(unit, momentOptions.relativeTimeThresholdOptions[unit]);\n      });\n    }\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\n@Pipe({ name: 'amFromUnix' })\nexport class FromUnixPipe implements PipeTransform {\n  transform(value: number | string, ...args: string[]): any {\n    return typeof value === 'string' ? moment.unix(parseInt(value, 10)) : moment.unix(value);\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amParse' })\nexport class ParsePipe implements PipeTransform {\n  transform(value: moment.MomentInput, formats: string | string[]): moment.Moment {\n    return momentConstructor(value, formats);\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\n@Pipe({ name: 'amFromUtc' })\nexport class FromUtcPipe implements PipeTransform {\n  transform(value: moment.MomentInput, formats?: string | string[], ...args: string[]): any {\n    return formats ? moment.utc(value, formats) : moment.utc(value);\n  }\n}\n","import * as moment from 'moment';\n\nimport { Pipe, PipeTransform } from '@angular/core';\n\nconst momentConstructor = moment;\n\n@Pipe({\n  name: 'amIsAfter',\n})\nexport class IsAfterPipe implements PipeTransform {\n  transform(\n    value: moment.MomentInput,\n    otherValue: moment.MomentInput,\n    unit?: moment.unitOfTime.StartOf,\n  ): boolean {\n    return momentConstructor(value).isAfter(momentConstructor(otherValue), unit);\n  }\n}\n","import * as moment from 'moment';\n\nimport { Pipe, PipeTransform } from '@angular/core';\n\nconst momentConstructor = moment;\n\n@Pipe({\n  name: 'amIsBefore',\n})\nexport class IsBeforePipe implements PipeTransform {\n  transform(\n    value: moment.MomentInput,\n    otherValue: moment.MomentInput,\n    unit?: moment.unitOfTime.StartOf,\n  ): boolean {\n    return momentConstructor(value).isBefore(momentConstructor(otherValue), unit);\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amLocal' })\nexport class LocalTimePipe implements PipeTransform {\n  transform(value: moment.MomentInput): moment.Moment {\n    return momentConstructor(value).local();\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\n// See https://github.com/ng-packagr/ng-packagr/issues/217 for why this is needed:\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amLocale' })\nexport class LocalePipe implements PipeTransform {\n  transform(value: moment.MomentInput, locale: string): moment.Moment {\n    return momentConstructor(value).locale(locale);\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\n@Pipe({ name: 'amParseZone' })\nexport class ParseZonePipe implements PipeTransform {\n  transform(value: moment.MomentInput): moment.Moment {\n    return moment.parseZone(value);\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amSubtract' })\nexport class SubtractPipe implements PipeTransform {\n  transform(\n    value: moment.MomentInput,\n    amount: moment.DurationInputArg1,\n    unit?: moment.DurationInputArg2,\n  ): any {\n    if (\n      typeof amount === 'undefined' ||\n      (typeof amount === 'number' && typeof unit === 'undefined')\n    ) {\n      throw new Error('SubtractPipe: missing required arguments');\n    }\n    return momentConstructor(value).subtract(amount, unit);\n  }\n}\n","/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */\n\nimport { Pipe, ChangeDetectorRef, PipeTransform, OnDestroy, NgZone } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amTimeAgo', pure: false })\nexport class TimeAgoPipe implements PipeTransform, OnDestroy {\n  private currentTimer: number | null;\n\n  private lastTime: Number;\n  private lastValue: moment.MomentInput;\n  private lastOmitSuffix: boolean;\n  private lastLocale?: string;\n  private lastText: string;\n  private formatFn: (m: moment.Moment) => string;\n\n  constructor(private cdRef: ChangeDetectorRef, private ngZone: NgZone) {}\n\n  format(m: moment.Moment) {\n    return m.from(momentConstructor(), this.lastOmitSuffix);\n  }\n\n  transform(\n    value: moment.MomentInput,\n    omitSuffix?: boolean,\n    formatFn?: (m: moment.Moment) => string,\n  ): string {\n    if (this.hasChanged(value, omitSuffix)) {\n      this.lastTime = this.getTime(value);\n      this.lastValue = value;\n      this.lastOmitSuffix = omitSuffix;\n      this.lastLocale = this.getLocale(value);\n      this.formatFn = formatFn || this.format.bind(this);\n      this.removeTimer();\n      this.createTimer();\n      this.lastText = this.formatFn(momentConstructor(value));\n    } else {\n      this.createTimer();\n    }\n\n    return this.lastText;\n  }\n\n  ngOnDestroy(): void {\n    this.removeTimer();\n  }\n\n  private createTimer() {\n    if (this.currentTimer) {\n      return;\n    }\n\n    const momentInstance = momentConstructor(this.lastValue);\n    const timeToUpdate = this.getSecondsUntilUpdate(momentInstance) * 1000;\n\n    this.currentTimer = this.ngZone.runOutsideAngular(() => {\n      if (typeof window !== 'undefined') {\n        return window.setTimeout(() => {\n          this.lastText = this.formatFn(momentConstructor(this.lastValue));\n\n          this.currentTimer = null;\n          this.ngZone.run(() => this.cdRef.markForCheck());\n        }, timeToUpdate);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  private removeTimer() {\n    if (this.currentTimer) {\n      window.clearTimeout(this.currentTimer);\n      this.currentTimer = null;\n    }\n  }\n\n  private getSecondsUntilUpdate(momentInstance: moment.Moment) {\n    const howOld = Math.abs(momentConstructor().diff(momentInstance, 'minute'));\n    if (howOld < 1) {\n      return 1;\n    } else if (howOld < 60) {\n      return 30;\n    } else if (howOld < 180) {\n      return 300;\n    } else {\n      return 3600;\n    }\n  }\n\n  private hasChanged(value: moment.MomentInput, omitSuffix?: boolean): boolean {\n    return (\n      this.getTime(value) !== this.lastTime ||\n      this.getLocale(value) !== this.lastLocale ||\n      omitSuffix !== this.lastOmitSuffix\n    );\n  }\n\n  private getTime(value: moment.MomentInput): number {\n    if (moment.isDate(value)) {\n      return value.getTime();\n    } else if (moment.isMoment(value)) {\n      return value.valueOf();\n    } else {\n      return momentConstructor(value).valueOf();\n    }\n  }\n\n  private getLocale(value: moment.MomentInput): string | null {\n    return moment.isMoment(value) ? value.locale() : moment.locale();\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from 'moment';\n\nconst momentConstructor = moment;\n\n@Pipe({ name: 'amUtc' })\nexport class UtcPipe implements PipeTransform {\n  transform(value: moment.MomentInput): moment.Moment {\n    return momentConstructor(value).utc();\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { NGX_MOMENT_OPTIONS, NgxMomentOptions } from './moment-options';\n\nimport { AddPipe } from './add.pipe';\nimport { CalendarPipe } from './calendar.pipe';\nimport { DateFormatPipe } from './date-format.pipe';\nimport { DifferencePipe } from './difference.pipe';\nimport { DurationPipe } from './duration.pipe';\nimport { FromUnixPipe } from './from-unix.pipe';\nimport { FromUtcPipe } from './from-utc.pipe';\nimport { IsAfterPipe } from './is-after.pipe';\nimport { IsBeforePipe } from './is-before.pipe';\nimport { LocalTimePipe } from './local.pipe';\nimport { LocalePipe } from './locale.pipe';\nimport { ParsePipe } from './parse.pipe';\nimport { ParseZonePipe } from './parse-zone.pipe';\nimport { SubtractPipe } from './subtract.pipe';\nimport { TimeAgoPipe } from './time-ago.pipe';\nimport { UtcPipe } from './utc.pipe';\n\nconst ANGULAR_MOMENT_PIPES = [\n  AddPipe,\n  CalendarPipe,\n  DateFormatPipe,\n  DifferencePipe,\n  DurationPipe,\n  FromUnixPipe,\n  ParsePipe,\n  SubtractPipe,\n  TimeAgoPipe,\n  UtcPipe,\n  FromUtcPipe,\n  LocalTimePipe,\n  LocalePipe,\n  ParseZonePipe,\n  IsBeforePipe,\n  IsAfterPipe,\n];\n\n@NgModule({\n  declarations: ANGULAR_MOMENT_PIPES,\n  exports: ANGULAR_MOMENT_PIPES,\n})\nexport class MomentModule {\n  static forRoot(options?: NgxMomentOptions): ModuleWithProviders<MomentModule> {\n    return {\n      ngModule: MomentModule,\n      providers: [\n        {\n          provide: NGX_MOMENT_OPTIONS,\n          useValue: {\n            ...options,\n          },\n        },\n      ],\n    };\n  }\n}\n"]}